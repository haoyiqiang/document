# PositionControlComponent API

> **ÁªßÊâøÂÖ≥Á≥ª**: Component > PositionControlComponent  
> **ÊéßÂà∂Á±ªÂûã**: Áõ¥Êé•‰ΩçÁΩÆÊéßÂà∂

ÈÄöËøáÁé©ÂÆ∂ËæìÂÖ•Áõ¥Êé•ËÆæÁΩÆÂÆû‰Ωì‰ΩçÁΩÆÁöÑÁªÑ‰ª∂Ôºå‰∏çÊ∂âÂèä‰ªª‰ΩïÁâ©ÁêÜËÆ°ÁÆó„ÄÇÊîØÊåÅ‰∏ª/ÂâØËæìÂÖ•ËΩ¥ÔºåÂèØÁî®‰∫éÊéßÂà∂ÊëÑÂÉèÊú∫„ÄÅÁûÑÂáÜÂÖâÊ†áÁ≠âÈúÄË¶ÅÁ≤æÁ°ÆÊéßÂà∂ÁöÑÂÖÉÁ¥†„ÄÇ

## ‚ú® ‰∏ªË¶ÅÁâπÊÄß

- üéÆ Áõ¥Êé•‰ΩçÁΩÆÊéßÂà∂ÔºåÊó†Áâ©ÁêÜËÆ°ÁÆó
- üïπÔ∏è ÂèåËΩ¥ËæìÂÖ•ÊîØÊåÅÔºà‰∏ªËΩ¥/ÂâØËΩ¥Ôºâ
- ‚ö° ÂèØË∞ÉËäÇÁßªÂä®ÈÄüÂ∫¶
- üéØ Á≤æÁ°ÆÁöÑ‰ΩçÁΩÆÊéßÂà∂
- üîÑ ÂèØÂêØÁî®/Á¶ÅÁî®ÂäüËÉΩ

## üìä ÂØºÂá∫Â±ûÊÄß

### ÊéßÂà∂ËÆæÁΩÆ
| Â±ûÊÄß | Á±ªÂûã | ÈªòËÆ§ÂÄº | ÊèèËø∞ |
|------|------|--------|------|
| `speed` | `float` | `200.0` | ÁßªÂä®ÈÄüÂ∫¶ (0-1000) |
| `shouldUseSecondaryAxis` | `bool` | `false` | ÊòØÂê¶‰ΩøÁî®ÂâØËΩ¥ËæìÂÖ•ÔºàÂè≥ÊëáÊùÜÔºâ |
| `isEnabled` | `bool` | `true` | ÊòØÂê¶ÂêØÁî®‰ΩçÁΩÆÊéßÂà∂ |

### Áä∂ÊÄÅÂ±ûÊÄß
| Â±ûÊÄß | Á±ªÂûã | ÊèèËø∞ |
|------|------|------|
| `lastInput` | `Vector2` | ‰∏ä‰∏ÄÂ∏ßÁöÑËæìÂÖ•ÂêëÈáè |

## üéÆ ËæìÂÖ•ÊéßÂà∂

### ‰∏ªËΩ¥ËæìÂÖ•ÔºàÈªòËÆ§Ôºâ
- **Â∑¶**: `moveLeft` / A / ‚Üê
- **Âè≥**: `moveRight` / D / ‚Üí  
- **‰∏ä**: `moveUp` / W / ‚Üë
- **‰∏ã**: `moveDown` / S / ‚Üì

### ÂâØËΩ¥ËæìÂÖ•ÔºàÂè≥ÊëáÊùÜÊ®°ÂºèÔºâ
- **Â∑¶**: `lookLeft` / Âè≥ÊëáÊùÜÂ∑¶
- **Âè≥**: `lookRight` / Âè≥ÊëáÊùÜÂè≥
- **‰∏ä**: `lookUp` / Âè≥ÊëáÊùÜ‰∏ä  
- **‰∏ã**: `lookDown` / Âè≥ÊëáÊùÜ‰∏ã

## üéØ ‰ΩøÁî®Á§∫‰æã

### Âü∫Á°ÄÂÖâÊ†áÊéßÂà∂

```gdscript
# Entity Scene Structure:
# ‚îî‚îÄ‚îÄ Cursor (Node2D)
#     ‚îú‚îÄ‚îÄ Sprite2D
#     ‚îî‚îÄ‚îÄ PositionControlComponent
#         speed: 300.0
#         shouldUseSecondaryAxis: false
```

### ÊëÑÂÉèÊú∫ÊéßÂà∂

```gdscript
# Entity Scene Structure:
# ‚îî‚îÄ‚îÄ CameraController (Node2D)
#     ‚îú‚îÄ‚îÄ Camera2D
#     ‚îî‚îÄ‚îÄ PositionControlComponent
#         speed: 150.0
#         shouldUseSecondaryAxis: true  # ‰ΩøÁî®Âè≥ÊëáÊùÜ
```

### ÂèåÈáçÊéßÂà∂Á≥ªÁªü

```gdscript
# DualControlComponent.gd
extends PositionControlComponent

@export var primarySpeed: float = 200.0
@export var secondarySpeed: float = 100.0
@export var enablePrecisionMode: bool = true

var isPrecisionMode: bool = false

func _process(delta: float):
    if not isEnabled:
        return
    
    # Ê£ÄÊü•Á≤æÁ°ÆÊ®°Âºè
    updatePrecisionMode()
    
    # Ëé∑ÂèñËæìÂÖ•
    var inputVector = getInputVector()
    
    # Â∫îÁî®ÈÄüÂ∫¶‰øÆÈ•∞Á¨¶
    var currentSpeed = getPrecisionAdjustedSpeed()
    
    # Êõ¥Êñ∞‰ΩçÁΩÆ
    parentEntity.position += inputVector * currentSpeed * delta

func _input(event: InputEvent):
    if enablePrecisionMode and event.is_action_pressed("precision_mode"):
        isPrecisionMode = not isPrecisionMode
        print("Precision mode: ", isPrecisionMode)

func updatePrecisionMode():
    if enablePrecisionMode:
        isPrecisionMode = Input.is_action_pressed("precision_mode")

func getInputVector() -> Vector2:
    if shouldUseSecondaryAxis:
        return Input.get_vector(
            GlobalInput.Actions.lookLeft,
            GlobalInput.Actions.lookRight,
            GlobalInput.Actions.lookUp,
            GlobalInput.Actions.lookDown)
    else:
        return Input.get_vector(
            GlobalInput.Actions.moveLeft,
            GlobalInput.Actions.moveRight,
            GlobalInput.Actions.moveUp,
            GlobalInput.Actions.moveDown)

func getPrecisionAdjustedSpeed() -> float:
    var baseSpeed = secondarySpeed if shouldUseSecondaryAxis else primarySpeed
    return baseSpeed * (0.3 if isPrecisionMode else 1.0)
```

### ËæπÁïåÈôêÂà∂ÊéßÂà∂

```gdscript
# BoundedPositionComponent.gd
extends PositionControlComponent

@export var boundaryRect: Rect2 = Rect2()
@export var enableBoundaries: bool = false
@export var bounceOnBoundary: bool = false
@export var wrapAroundBoundary: bool = false

func _process(delta: float):
    if not isEnabled:
        return
    
    # Ëé∑ÂèñËæìÂÖ•
    var inputVector = getInputVector()
    
    # ËÆ°ÁÆóÊñ∞‰ΩçÁΩÆ
    var newPosition = parentEntity.position + inputVector * speed * delta
    
    # Â∫îÁî®ËæπÁïåÊ£ÄÊü•
    if enableBoundaries:
        newPosition = applyBoundaryConstraints(newPosition, inputVector)
    
    parentEntity.position = newPosition

func getInputVector() -> Vector2:
    if shouldUseSecondaryAxis:
        return Input.get_vector(
            GlobalInput.Actions.lookLeft,
            GlobalInput.Actions.lookRight,
            GlobalInput.Actions.lookUp,
            GlobalInput.Actions.lookDown)
    else:
        return Input.get_vector(
            GlobalInput.Actions.moveLeft,
            GlobalInput.Actions.moveRight,
            GlobalInput.Actions.moveUp,
            GlobalInput.Actions.moveDown)

func applyBoundaryConstraints(newPosition: Vector2, inputVector: Vector2) -> Vector2:
    if wrapAroundBoundary:
        return wrapPosition(newPosition)
    elif bounceOnBoundary:
        return bouncePosition(newPosition, inputVector)
    else:
        return clampPosition(newPosition)

func clampPosition(position: Vector2) -> Vector2:
    return Vector2(
        clamp(position.x, boundaryRect.position.x, boundaryRect.position.x + boundaryRect.size.x),
        clamp(position.y, boundaryRect.position.y, boundaryRect.position.y + boundaryRect.size.y)
    )

func wrapPosition(position: Vector2) -> Vector2:
    var wrappedX = position.x
    var wrappedY = position.y
    
    if wrappedX < boundaryRect.position.x:
        wrappedX = boundaryRect.position.x + boundaryRect.size.x
    elif wrappedX > boundaryRect.position.x + boundaryRect.size.x:
        wrappedX = boundaryRect.position.x
    
    if wrappedY < boundaryRect.position.y:
        wrappedY = boundaryRect.position.y + boundaryRect.size.y
    elif wrappedY > boundaryRect.position.y + boundaryRect.size.y:
        wrappedY = boundaryRect.position.y
    
    return Vector2(wrappedX, wrappedY)

func bouncePosition(position: Vector2, inputVector: Vector2) -> Vector2:
    # ÁÆÄÂçïÁöÑÂèçÂºπÈÄªËæë
    var clampedPosition = clampPosition(position)
    
    # Â¶ÇÊûú‰ΩçÁΩÆË¢´ÈôêÂà∂ÔºåÂèçËΩ¨ËæìÂÖ•ÊñπÂêë
    if clampedPosition != position:
        # ËøôÈáåÂèØ‰ª•Ê∑ªÂä†ÂèçÂºπÊïàÊûú
        print("Boundary hit!")
    
    return clampedPosition

func setBoundaryRect(rect: Rect2):
    boundaryRect = rect
```

### ÊÉØÊÄßÊéßÂà∂ÁªÑ‰ª∂

```gdscript
# InertiaPositionComponent.gd
extends PositionControlComponent

@export var inertiaEnabled: bool = false
@export var acceleration: float = 500.0
@export var friction: float = 200.0
@export var maxVelocity: float = 300.0

var velocity: Vector2 = Vector2.ZERO

func _process(delta: float):
    if not isEnabled:
        return
    
    var inputVector = getInputVector()
    
    if inertiaEnabled:
        processInertialMovement(inputVector, delta)
    else:
        processDirectMovement(inputVector, delta)

func getInputVector() -> Vector2:
    if shouldUseSecondaryAxis:
        return Input.get_vector(
            GlobalInput.Actions.lookLeft,
            GlobalInput.Actions.lookRight,
            GlobalInput.Actions.lookUp,
            GlobalInput.Actions.lookDown)
    else:
        return Input.get_vector(
            GlobalInput.Actions.moveLeft,
            GlobalInput.Actions.moveRight,
            GlobalInput.Actions.moveUp,
            GlobalInput.Actions.moveDown)

func processDirectMovement(inputVector: Vector2, delta: float):
    # Ê†áÂáÜÁöÑÁõ¥Êé•‰ΩçÁΩÆÊéßÂà∂
    parentEntity.position += inputVector * speed * delta
    lastInput = inputVector

func processInertialMovement(inputVector: Vector2, delta: float):
    # Â∏¶ÊÉØÊÄßÁöÑÊéßÂà∂
    if inputVector.length() > 0:
        # ÊúâËæìÂÖ•Êó∂Âä†ÈÄü
        velocity += inputVector * acceleration * delta
    else:
        # Êó†ËæìÂÖ•Êó∂ÂáèÈÄü
        velocity = velocity.move_toward(Vector2.ZERO, friction * delta)
    
    # ÈôêÂà∂ÊúÄÂ§ßÈÄüÂ∫¶
    if velocity.length() > maxVelocity:
        velocity = velocity.normalized() * maxVelocity
    
    # Â∫îÁî®ÁßªÂä®
    parentEntity.position += velocity * delta
    lastInput = inputVector

func stopImmediately():
    velocity = Vector2.ZERO

func setInertiaEnabled(enabled: bool):
    inertiaEnabled = enabled
    if not enabled:
        stopImmediately()
```

### ÁΩëÊ†ºÂØπÈΩêÊéßÂà∂

```gdscript
# GridAlignedPositionComponent.gd
extends PositionControlComponent

@export var gridSize: Vector2 = Vector2(32, 32)
@export var snapToGrid: bool = true
@export var smoothSnapping: bool = false
@export var snapSpeed: float = 500.0

var targetGridPosition: Vector2
var isSnapping: bool = false

func _process(delta: float):
    if not isEnabled:
        return
    
    if isSnapping and smoothSnapping:
        processGridSnapping(delta)
    else:
        processNormalMovement(delta)

func processNormalMovement(delta: float):
    var inputVector = getInputVector()
    
    if snapToGrid:
        # ÁΩëÊ†ºÁßªÂä®
        processGridMovement(inputVector)
    else:
        # Ëá™Áî±ÁßªÂä®
        parentEntity.position += inputVector * speed * delta
    
    lastInput = inputVector

func processGridMovement(inputVector: Vector2):
    if inputVector.length() == 0 or isSnapping:
        return
    
    # Á°ÆÂÆöÁßªÂä®ÊñπÂêë
    var direction = Vector2.ZERO
    if abs(inputVector.x) > abs(inputVector.y):
        direction.x = sign(inputVector.x)
    else:
        direction.y = sign(inputVector.y)
    
    # ËÆ°ÁÆóÁõÆÊ†áÁΩëÊ†º‰ΩçÁΩÆ
    targetGridPosition = snapPositionToGrid(parentEntity.position + direction * gridSize)
    
    if smoothSnapping:
        isSnapping = true
    else:
        parentEntity.position = targetGridPosition

func processGridSnapping(delta: float):
    parentEntity.position = parentEntity.position.move_toward(targetGridPosition, snapSpeed * delta)
    
    if parentEntity.position.distance_to(targetGridPosition) < 1.0:
        parentEntity.position = targetGridPosition
        isSnapping = false

func snapPositionToGrid(position: Vector2) -> Vector2:
    var snappedX = round(position.x / gridSize.x) * gridSize.x
    var snappedY = round(position.y / gridSize.y) * gridSize.y
    return Vector2(snappedX, snappedY)

func getInputVector() -> Vector2:
    if shouldUseSecondaryAxis:
        return Input.get_vector(
            GlobalInput.Actions.lookLeft,
            GlobalInput.Actions.lookRight,
            GlobalInput.Actions.lookUp,
            GlobalInput.Actions.lookDown)
    else:
        return Input.get_vector(
            GlobalInput.Actions.moveLeft,
            GlobalInput.Actions.moveRight,
            GlobalInput.Actions.moveUp,
            GlobalInput.Actions.moveDown)

func setGridSize(newSize: Vector2):
    gridSize = newSize

func alignToGrid():
    parentEntity.position = snapPositionToGrid(parentEntity.position)
```

## üîß ÊäÄÊúØÁªÜËäÇ

### ËæìÂÖ•Â§ÑÁêÜ
```gdscript
func _process(delta: float) -> void:
    if not isEnabled: return
    
    if shouldUseSecondaryAxis:
        lastInput = Input.get_vector(
            GlobalInput.Actions.lookLeft,
            GlobalInput.Actions.lookRight,
            GlobalInput.Actions.lookUp,
            GlobalInput.Actions.lookDown)
    else:
        lastInput = Input.get_vector(
            GlobalInput.Actions.moveLeft,
            GlobalInput.Actions.moveRight,
            GlobalInput.Actions.moveUp,
            GlobalInput.Actions.moveDown)

    parentEntity.position += lastInput * speed * delta
```

### ÊÄßËÉΩËÄÉËôë
- ‰ΩøÁî®`_process()`ËÄåÈùû`_physics_process()`ÔºåÈÄÇÁî®‰∫éUIÂÖÉÁ¥†
- ÈÄöËøá`isEnabled`Âø´ÈÄüÁ¶ÅÁî®Â§ÑÁêÜ
- `lastInput`ÂèØ‰æõÂ≠êÁ±ªËÆøÈóÆÂíå‰ΩøÁî®

## ‚ö†Ô∏è Ê≥®ÊÑè‰∫ãÈ°π

1. **Êó†Áâ©ÁêÜ**: ‰∏çÊ∂âÂèä‰ªª‰ΩïÁâ©ÁêÜËÆ°ÁÆóÔºåÁõ¥Êé•‰øÆÊîπposition
2. **ÂùêÊ†áÁ≥ªÁªü**: ‰øÆÊîπÁöÑÊòØÂ±ÄÈÉ®positionÔºå‰∏çÊòØglobal_position
3. **ËæìÂÖ•ËΩ¥ÈÄâÊã©**: ‰∏ªËΩ¥Áî®‰∫éÁßªÂä®ÔºåÂâØËΩ¥Áî®‰∫éÊëÑÂÉèÊú∫/ÁûÑÂáÜ
4. **Â§ÑÁêÜÊ®°Âºè**: ‰ΩøÁî®`_process()`ËÄåÈùû`_physics_process()`
5. **Â≠êÁ±ªÊâ©Â±ï**: Â≠êÁ±ªÂèØ‰ª•ËÆøÈóÆ`lastInput`ËøõË°åÈ¢ùÂ§ñÂ§ÑÁêÜ

## üîó Áõ∏ÂÖ≥ÁªÑ‰ª∂

- [MouseTrackingComponent](MouseTrackingComponent.md) - Èº†Ê†áË∑üË∏™ÁªÑ‰ª∂
- [InputComponent](InputComponent.md) - ËæìÂÖ•ÁÆ°ÁêÜÁªÑ‰ª∂
- [TileBasedMouseControlComponent](TileBasedMouseControlComponent.md) - Áì¶ÁâáÈº†Ê†áÊéßÂà∂
- [Component](../Component.md) - Âü∫Á°ÄÁªÑ‰ª∂Á±ª

---

**ÁâàÊú¨**: Comedot Framework v1.0  
**ÊñáÊ°£Êõ¥Êñ∞**: 2024-12-21 