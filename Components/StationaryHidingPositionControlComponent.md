# StationaryHidingPositionControlComponent API

> **ÁªßÊâøÂÖ≥Á≥ª**: Component > PositionControlComponent > StationaryHidingPositionControlComponent  
> **ÊéßÂà∂Á±ªÂûã**: Ëá™Âä®ÈöêËóè‰ΩçÁΩÆÊéßÂà∂  
> **‰æùËµñÁªÑ‰ª∂**: ÂèØ‰∏éMouseTrackingComponentÈÖçÂêà

ÁªßÊâøËá™PositionControlComponentÁöÑÊô∫ËÉΩÈöêËóèÊéßÂà∂ÁªÑ‰ª∂„ÄÇÂΩìÊ≤°ÊúâÁé©ÂÆ∂ËæìÂÖ•Êó∂Ëá™Âä®ÈöêËóèÂÆû‰ΩìÔºåÈÄÇÁî®‰∫éÁûÑÂáÜÂÖâÊ†á„ÄÅUIÂÖÉÁ¥†Á≠âÈúÄË¶ÅÊô∫ËÉΩÊòæÁ§∫/ÈöêËóèÁöÑÁªÑ‰ª∂„ÄÇ

## ‚ú® ‰∏ªË¶ÅÁâπÊÄß

- ü´• Êó†ËæìÂÖ•Êó∂Ëá™Âä®ÈöêËóè
- üéÆ ÊîØÊåÅÊâãÊüÑÂíåÈº†Ê†áÂèåÈáçÊéßÂà∂
- üì∫ Âπ≥ÊªëÊ∑°ÂÖ•Ê∑°Âá∫Âä®Áîª
- ‚è∞ ÂèØÈÖçÁΩÆÈöêËóèÂª∂Ëøü
- üñ±Ô∏è Èº†Ê†áÁßªÂä®Êô∫ËÉΩÊòæÁ§∫
- üîÑ ÂÆåÂÖ®ÂÖºÂÆπ‰ΩçÁΩÆÊéßÂà∂ÂäüËÉΩ

## üìä ÂØºÂá∫Â±ûÊÄß

### ÈöêËóèÊéßÂà∂
| Â±ûÊÄß | Á±ªÂûã | ÈªòËÆ§ÂÄº | ÊèèËø∞ |
|------|------|--------|------|
| `shouldHideOnReady` | `bool` | `true` | ÁªÑ‰ª∂Â∞±Áª™Êó∂ÊòØÂê¶Á´ãÂç≥ÈöêËóèÂÆû‰Ωì |

### Âä®ÁîªËÆæÁΩÆ
| Â±ûÊÄß | Á±ªÂûã | ÈªòËÆ§ÂÄº | ÊèèËø∞ |
|------|------|--------|------|
| `animationDuration` | `float` | `0.5` | Ê∑°ÂÖ•Ê∑°Âá∫Âä®ÁîªÊåÅÁª≠Êó∂Èó¥ |

### ÁªßÊâøÂ±ûÊÄß
ÁªßÊâøËá™PositionControlComponentÁöÑÊâÄÊúâÂ±ûÊÄßÔºö
- `speed` - ÁßªÂä®ÈÄüÂ∫¶
- `shouldUseSecondaryAxis` - ÊòØÂê¶‰ΩøÁî®ÂâØËΩ¥ËæìÂÖ•
- `isEnabled` - ÊòØÂê¶ÂêØÁî®ÊéßÂà∂

### Áä∂ÊÄÅÂ±ûÊÄß
| Â±ûÊÄß | Á±ªÂûã | ÊèèËø∞ |
|------|------|------|
| `hidingTimer` | `Timer` | ÈöêËóèÂª∂ËøüËÆ°Êó∂Âô® |
| `tween` | `Tween` | Ê∑°ÂÖ•Ê∑°Âá∫Âä®ÁîªË°•Èó¥ |
| `haveMouseTrackingComponent` | `bool` | ÊòØÂê¶Â≠òÂú®Èº†Ê†áË∑üË∏™ÁªÑ‰ª∂ |

## üéØ ‰ΩøÁî®Á§∫‰æã

### Âü∫Á°ÄÁûÑÂáÜÂÖâÊ†á

```gdscript
# Entity Scene Structure:
# ‚îî‚îÄ‚îÄ AimCursor (Node2D)
#     ‚îú‚îÄ‚îÄ Sprite2D
#     ‚îú‚îÄ‚îÄ StationaryHidingPositionControlComponent
#     ‚îÇ   ‚îú‚îÄ‚îÄ HidingTimer
#     ‚îÇ   ‚îî‚îÄ‚îÄ [ËÆæÁΩÆ]
#     ‚îÇ       shouldHideOnReady: true
#     ‚îÇ       speed: 300.0
#     ‚îî‚îÄ‚îÄ [ÂèØÈÄâ] MouseTrackingComponent
```

### Êô∫ËÉΩUIÂÖâÊ†áÁ≥ªÁªü

```gdscript
# SmartCursorComponent.gd
extends StationaryHidingPositionControlComponent

@export var adaptiveSpeed: bool = true
@export var baseSpeed: float = 200.0
@export var maxSpeed: float = 600.0
@export var showOnTargetFound: bool = true
@export var targetDetectionRadius: float = 50.0

var targetsInRange: Array[Node2D] = []
var isOverTarget: bool = false

func _ready():
    super._ready()
    setupTargetDetection()

func setupTargetDetection():
    # ËÆæÁΩÆÂå∫ÂüüÊ£ÄÊµã
    var area = Area2D.new()
    var shape = CircleShape2D.new()
    shape.radius = targetDetectionRadius
    var collision = CollisionShape2D.new()
    collision.shape = shape
    
    parentEntity.add_child(area)
    area.add_child(collision)
    
    area.area_entered.connect(_on_target_entered)
    area.area_exited.connect(_on_target_exited)
    area.body_entered.connect(_on_target_entered)
    area.body_exited.connect(_on_target_exited)

func _process(delta: float):
    # Ëá™ÈÄÇÂ∫îÈÄüÂ∫¶
    if adaptiveSpeed:
        adjustSpeedBasedOnContext()
    
    # Â§ÑÁêÜÁõÆÊ†áÊÇ¨ÂÅúÊòæÁ§∫
    if showOnTargetFound and isOverTarget:
        showEntity()
    
    super._process(delta)

func adjustSpeedBasedOnContext():
    if isOverTarget:
        # Âú®ÁõÆÊ†á‰∏äÊñπÊó∂Èôç‰ΩéÈÄüÂ∫¶ÔºåÊèêÈ´òÁ≤æÂ∫¶
        speed = baseSpeed * 0.5
    elif targetsInRange.size() > 0:
        # ÁõÆÊ†áÈôÑËøëÊó∂‰∏≠Á≠âÈÄüÂ∫¶
        speed = baseSpeed * 0.8
    else:
        # Ëá™Áî±ÁßªÂä®Êó∂ÊúÄÂ§ßÈÄüÂ∫¶
        speed = maxSpeed

func _on_target_entered(target: Node):
    if target.has_method("is_targetable") and target.is_targetable():
        targetsInRange.append(target)
        isOverTarget = true
        
        # ÁõÆÊ†áÊÇ¨ÂÅúÊó∂ÊòæÁ§∫ÂÖâÊ†á
        if showOnTargetFound:
            showEntity()
        
        print("Target detected: ", target.name)

func _on_target_exited(target: Node):
    targetsInRange.erase(target)
    isOverTarget = targetsInRange.size() > 0
    
    print("Target lost: ", target.name)

func showEntity():
    # Ë¶ÜÁõñÁà∂Á±ªÊñπÊ≥ïÔºåÊ∑ªÂä†È¢ùÂ§ñÊïàÊûú
    super.showEntity()
    
    # Ê∑ªÂä†ËÑâÂÜ≤ÊïàÊûúË°®Á§∫ÊâæÂà∞ÁõÆÊ†á
    if isOverTarget:
        createPulseEffect()

func createPulseEffect():
    if tween:
        tween.kill()
    
    tween = parentEntity.create_tween()
    tween.set_loops(2)
    
    var originalScale = parentEntity.scale
    var pulseScale = originalScale * 1.2
    
    tween.tween_property(parentEntity, "scale", pulseScale, 0.1)
    tween.tween_property(parentEntity, "scale", originalScale, 0.1)

func getTargetsInRange() -> Array[Node2D]:
    return targetsInRange.duplicate()

func setTargetDetectionRadius(radius: float):
    targetDetectionRadius = radius
    # Êõ¥Êñ∞Á¢∞ÊíûÂΩ¢Áä∂...
```

### ‰∏ä‰∏ãÊñáÊïèÊÑüÂÖâÊ†á

```gdscript
# ContextSensitiveCursor.gd
extends StationaryHidingPositionControlComponent

@export var contextualAppearance: bool = true
@export var interactionModeSprite: Texture2D
@export var combatModeSprite: Texture2D
@export var navigationModeSprite: Texture2D

enum CursorMode {
    HIDDEN,
    INTERACTION,
    COMBAT,
    NAVIGATION
}

var currentMode: CursorMode = CursorMode.HIDDEN
var sprite: Sprite2D

func _ready():
    super._ready()
    sprite = parentEntity.get_node("Sprite2D")
    updateCursorAppearance()

func _process(delta: float):
    super._process(delta)
    
    if contextualAppearance:
        updateContextualMode()

func updateContextualMode():
    var newMode = determineContextualMode()
    
    if newMode != currentMode:
        setMode(newMode)

func determineContextualMode() -> CursorMode:
    # Ê£ÄÊü•ÊòØÂê¶Âú®UI‰∏ä
    if isOverInteractable():
        return CursorMode.INTERACTION
    
    # Ê£ÄÊü•ÊòØÂê¶Âú®Êïå‰∫∫ÈôÑËøë
    if isNearCombatTarget():
        return CursorMode.COMBAT
    
    # Ê£ÄÊü•ÊòØÂê¶ÊúâËæìÂÖ•
    if not lastInput.is_zero_approx():
        return CursorMode.NAVIGATION
    
    return CursorMode.HIDDEN

func isOverInteractable() -> bool:
    var space_state = parentEntity.get_world_2d().direct_space_state
    var query = PhysicsPointQueryParameters2D.new()
    query.position = parentEntity.global_position
    query.collision_mask = 1  # UIÂ±Ç
    
    var result = space_state.intersect_point(query)
    return not result.is_empty()

func isNearCombatTarget() -> bool:
    var enemies = get_tree().get_nodes_in_group("enemies")
    
    for enemy in enemies:
        var distance = parentEntity.global_position.distance_to(enemy.global_position)
        if distance < 100.0:  # 100ÂÉèÁ¥†ËåÉÂõ¥ÂÜÖ
            return true
    
    return false

func setMode(mode: CursorMode):
    currentMode = mode
    updateCursorAppearance()
    
    match mode:
        CursorMode.HIDDEN:
            hideEntity()
        CursorMode.INTERACTION:
            showEntity()
            speed = baseSpeed * 0.6  # ‰∫§‰∫íÊó∂ÈôçÈÄü
        CursorMode.COMBAT:
            showEntity()
            speed = baseSpeed * 1.2  # ÊàòÊñóÊó∂ÊèêÈÄü
        CursorMode.NAVIGATION:
            showEntity()
            speed = baseSpeed

func updateCursorAppearance():
    if not sprite:
        return
    
    match currentMode:
        CursorMode.INTERACTION:
            sprite.texture = interactionModeSprite
            sprite.modulate = Color.CYAN
        CursorMode.COMBAT:
            sprite.texture = combatModeSprite
            sprite.modulate = Color.RED
        CursorMode.NAVIGATION:
            sprite.texture = navigationModeSprite
            sprite.modulate = Color.WHITE
        _:
            sprite.modulate = Color.WHITE

func showEntity():
    super.showEntity()
    updateCursorAppearance()

# Ëá™ÂÆö‰πâËæìÂÖ•Â§ÑÁêÜ
func _input(event: InputEvent):
    super._input(event)
    
    # Âè≥ÈîÆÂàáÊç¢Ê®°Âºè
    if event.is_action_pressed("right_click"):
        cycleCursorMode()

func cycleCursorMode():
    var modes = [CursorMode.NAVIGATION, CursorMode.INTERACTION, CursorMode.COMBAT]
    var currentIndex = modes.find(currentMode)
    var nextIndex = (currentIndex + 1) % modes.size()
    setMode(modes[nextIndex])
    
    print("Cursor mode changed to: ", CursorMode.keys()[currentMode])
```

### Â§ö‰∫∫Ê∏∏ÊàèÂÖâÊ†áÂêåÊ≠•

```gdscript
# MultiplayerCursor.gd
extends StationaryHidingPositionControlComponent

@export var playerId: int = 0
@export var syncToNetwork: bool = true
@export var showOtherPlayers: bool = true
@export var playerColors: Array[Color] = [Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW]

var networkCursors: Dictionary = {}
var lastSyncTime: float = 0.0
var syncInterval: float = 0.1  # 10fpsÂêåÊ≠•

func _ready():
    super._ready()
    setupMultiplayerSync()

func setupMultiplayerSync():
    if not syncToNetwork:
        return
    
    # ËøûÊé•Â§ö‰∫∫Ê∏∏Êàè‰ø°Âè∑
    if multiplayer.has_method("peer_connected"):
        multiplayer.peer_connected.connect(_on_peer_connected)
        multiplayer.peer_disconnected.connect(_on_peer_disconnected)
    
    # ËÆæÁΩÆÁé©ÂÆ∂È¢úËâ≤
    if playerId < playerColors.size():
        var sprite = parentEntity.get_node_or_null("Sprite2D")
        if sprite:
            sprite.modulate = playerColors[playerId]

func _process(delta: float):
    super._process(delta)
    
    if syncToNetwork:
        handleNetworkSync(delta)

func handleNetworkSync(delta: float):
    lastSyncTime += delta
    
    if lastSyncTime >= syncInterval:
        syncCursorPosition()
        lastSyncTime = 0.0

@rpc("unreliable")
func syncCursorPosition():
    if not multiplayer.is_server():
        return
    
    var cursorData = {
        "player_id": playerId,
        "position": parentEntity.global_position,
        "visible": parentEntity.visible,
        "mode": currentMode if has_method("getCurrentMode") else 0
    }
    
    rpc("receiveCursorUpdate", cursorData)

@rpc("unreliable") 
func receiveCursorUpdate(cursorData: Dictionary):
    var otherPlayerId = cursorData.player_id
    
    if otherPlayerId == playerId:
        return  # ÂøΩÁï•Ëá™Â∑±ÁöÑÊï∞ÊçÆ
    
    updateOtherPlayerCursor(cursorData)

func updateOtherPlayerCursor(cursorData: Dictionary):
    var otherPlayerId = cursorData.player_id
    
    if not networkCursors.has(otherPlayerId):
        createNetworkCursor(otherPlayerId)
    
    var otherCursor = networkCursors[otherPlayerId]
    otherCursor.global_position = cursorData.position
    otherCursor.visible = cursorData.visible and showOtherPlayers

func createNetworkCursor(otherPlayerId: int):
    var cursorNode = Node2D.new()
    var sprite = Sprite2D.new()
    
    # Â§çÂà∂ÂΩìÂâçÂÖâÊ†áÁöÑÂ§ñËßÇ
    var mySprite = parentEntity.get_node_or_null("Sprite2D")
    if mySprite:
        sprite.texture = mySprite.texture
        sprite.scale = mySprite.scale * 0.8  # Á®çÂ∞è‰∏Ä‰∫õ
    
    # ËÆæÁΩÆÁé©ÂÆ∂È¢úËâ≤
    if otherPlayerId < playerColors.size():
        sprite.modulate = playerColors[otherPlayerId]
        sprite.modulate.a = 0.7  # ÂçäÈÄèÊòé
    
    cursorNode.add_child(sprite)
    get_tree().current_scene.add_child(cursorNode)
    
    networkCursors[otherPlayerId] = cursorNode
    
    print("Created network cursor for player: ", otherPlayerId)

func _on_peer_connected(id: int):
    print("Player connected: ", id)

func _on_peer_disconnected(id: int):
    if networkCursors.has(id):
        networkCursors[id].queue_free()
        networkCursors.erase(id)
        print("Removed cursor for disconnected player: ", id)

func _exit_tree():
    # Ê∏ÖÁêÜÁΩëÁªúÂÖâÊ†á
    for cursor in networkCursors.values():
        if cursor:
            cursor.queue_free()
    networkCursors.clear()
```

### ËæÖÂä©ÂäüËÉΩÊîØÊåÅÂÖâÊ†á

```gdscript
# AccessibilityCursor.gd
extends StationaryHidingPositionControlComponent

@export var voiceAnnouncements: bool = false
@export var snapToTargets: bool = false
@export var snapDistance: float = 30.0
@export var highlightTargets: bool = true
@export var contrastMode: bool = false

var tts: TTSInterface
var snapTargets: Array[Node2D] = []
var currentHighlight: Node2D

func _ready():
    super._ready()
    setupAccessibility()

func setupAccessibility():
    # ËÆæÁΩÆTTSÔºàÊñáÂ≠óËΩ¨ËØ≠Èü≥Ôºâ
    if voiceAnnouncements and Engine.has_singleton("TTS"):
        tts = Engine.get_singleton("TTS")
    
    # ËÆæÁΩÆÂØπÊØîÂ∫¶Ê®°Âºè
    if contrastMode:
        enableContrastMode()
    
    # Êâ´ÊèèÂèØÂê∏ÈôÑÁõÆÊ†á
    if snapToTargets:
        updateSnapTargets()

func _process(delta: float):
    super._process(delta)
    
    if snapToTargets:
        handleTargetSnapping()
    
    if highlightTargets:
        updateTargetHighlight()

func handleTargetSnapping():
    if lastInput.is_zero_approx():
        return
    
    var nearestTarget = findNearestSnapTarget()
    if nearestTarget:
        var distance = parentEntity.global_position.distance_to(nearestTarget.global_position)
        if distance < snapDistance:
            # Âê∏ÈôÑÂà∞ÁõÆÊ†á
            parentEntity.global_position = nearestTarget.global_position
            announceTarget(nearestTarget)

func findNearestSnapTarget() -> Node2D:
    var nearest: Node2D = null
    var minDistance = snapDistance
    
    for target in snapTargets:
        if not target or not is_instance_valid(target):
            continue
        
        var distance = parentEntity.global_position.distance_to(target.global_position)
        if distance < minDistance:
            minDistance = distance
            nearest = target
    
    return nearest

func updateTargetHighlight():
    var nearestTarget = findNearestSnapTarget()
    
    if nearestTarget != currentHighlight:
        # Ê∏ÖÈô§ÊóßÈ´ò‰∫Æ
        if currentHighlight:
            removeHighlight(currentHighlight)
        
        # Ê∑ªÂä†Êñ∞È´ò‰∫Æ
        if nearestTarget:
            addHighlight(nearestTarget)
        
        currentHighlight = nearestTarget

func addHighlight(target: Node2D):
    var highlight = ColorRect.new()
    highlight.color = Color.YELLOW
    highlight.color.a = 0.3
    highlight.size = Vector2(40, 40)
    highlight.position = Vector2(-20, -20)
    highlight.name = "AccessibilityHighlight"
    
    target.add_child(highlight)

func removeHighlight(target: Node2D):
    var highlight = target.get_node_or_null("AccessibilityHighlight")
    if highlight:
        highlight.queue_free()

func announceTarget(target: Node2D):
    if not voiceAnnouncements or not tts:
        return
    
    var announcement = "Target: " + target.name
    if target.has_method("getAccessibilityDescription"):
        announcement = target.getAccessibilityDescription()
    
    tts.speak(announcement)

func updateSnapTargets():
    snapTargets.clear()
    
    # Êî∂ÈõÜÂèØ‰∫§‰∫íÁöÑÁõÆÊ†á
    var interactables = get_tree().get_nodes_in_group("interactable")
    var buttons = get_tree().get_nodes_in_group("ui_buttons")
    
    snapTargets.append_array(interactables)
    snapTargets.append_array(buttons)
    
    print("Updated snap targets: ", snapTargets.size())

func enableContrastMode():
    # È´òÂØπÊØîÂ∫¶ËÆæÁΩÆ
    var sprite = parentEntity.get_node_or_null("Sprite2D")
    if sprite:
        sprite.modulate = Color.WHITE
        # Ê∑ªÂä†ÈªëËâ≤ËæπÊ°Ü
        var outline = Sprite2D.new()
        outline.texture = sprite.texture
        outline.modulate = Color.BLACK
        outline.scale = Vector2(1.1, 1.1)
        outline.z_index = sprite.z_index - 1
        sprite.add_sibling(outline)

func _input(event: InputEvent):
    super._input(event)
    
    # ËæÖÂä©ÂäüËÉΩÂø´Êç∑ÈîÆ
    if event.is_action_pressed("accessibility_announce"):
        announceCurrentContext()
    elif event.is_action_pressed("accessibility_snap_next"):
        snapToNextTarget()

func announceCurrentContext():
    if not voiceAnnouncements or not tts:
        return
    
    var context = "Cursor at " + str(parentEntity.global_position)
    if currentHighlight:
        context += ". Near " + currentHighlight.name
    
    tts.speak(context)

func snapToNextTarget():
    if snapTargets.is_empty():
        updateSnapTargets()
        return
    
    var currentIndex = snapTargets.find(currentHighlight) if currentHighlight else -1
    var nextIndex = (currentIndex + 1) % snapTargets.size()
    var nextTarget = snapTargets[nextIndex]
    
    if nextTarget:
        parentEntity.global_position = nextTarget.global_position
        updateTargetHighlight()
        announceTarget(nextTarget)
```

## üîß ÊäÄÊúØÁªÜËäÇ

### ÈöêËóèÈÄªËæëÊµÅÁ®ã
```gdscript
func _process(delta: float) -> void:
    if lastInput.is_zero_approx():
        # Êó†ËæìÂÖ•Êó∂ÂêØÂä®ÈöêËóèËÆ°Êó∂Âô®
        if parentEntity.visible and hidingTimer.is_stopped():
            hidingTimer.start()
    else:
        # ÊúâËæìÂÖ•Êó∂Á´ãÂç≥ÊòæÁ§∫
        showEntity()
```

### Èº†Ê†áÂÖºÂÆπÊÄß
```gdscript
func _input(event: InputEvent) -> void:
    if haveMouseTrackingComponent and event is InputEventMouseMotion:
        if not parentEntity.visible:
            showEntity()
```

### Ê∑°ÂÖ•Ê∑°Âá∫Âä®Áîª
```gdscript
func hideEntity() -> void:
    tween = parentEntity.create_tween()
    var fadedModulate = parentEntity.modulate
    fadedModulate.a = 0
    tween.tween_property(parentEntity, "modulate", fadedModulate, animationDuration)
    tween.tween_property(parentEntity, "visible", false, 0)
```

## ‚ö†Ô∏è Ê≥®ÊÑè‰∫ãÈ°π

1. **ÁªÑ‰ª∂ÂÜ≤Á™Å**: ÂèØËÉΩ‰∏éMouseTrackingComponent‰∫ßÁîüÂÜ≤Á™ÅÔºå‰ΩÜËÆæËÆ°‰∏äÊòØÂÖºÂÆπÁöÑ
2. **ÂàùÂßãÁä∂ÊÄÅ**: shouldHideOnReady‰∏∫trueÊó∂ÔºåÁªÑ‰ª∂ÂêØÂä®Êó∂ÂÆû‰Ωì‰ºöË¢´ÈöêËóè
3. **Âä®ÁîªÊÄßËÉΩ**: ‰ΩøÁî®TweenÂÆûÁé∞Âπ≥ÊªëÂä®ÁîªÔºåÂ§ßÈáèÂÆû‰æãÂèØËÉΩÂΩ±ÂìçÊÄßËÉΩ
4. **ËæìÂÖ•Ê£ÄÊµã**: ÂêåÊó∂Ê£ÄÊµãÊâãÊüÑÂíåÈº†Ê†áËæìÂÖ•ÔºåÁ°Æ‰øùÂ§öÁßçÊéßÂà∂ÊñπÂºèÂÖºÂÆπ
5. **ÁªßÊâøÂÖ≥Á≥ª**: ÂÆåÂÖ®ÁªßÊâøPositionControlComponentÁöÑÊâÄÊúâÂäüËÉΩ

## üîó Áõ∏ÂÖ≥ÁªÑ‰ª∂

- [PositionControlComponent](PositionControlComponent.md) - Âü∫Á°Ä‰ΩçÁΩÆÊéßÂà∂ÁªÑ‰ª∂
- [MouseTrackingComponent](MouseTrackingComponent.md) - Èº†Ê†áË∑üË∏™ÁªÑ‰ª∂
- [InputComponent](InputComponent.md) - ËæìÂÖ•ÁÆ°ÁêÜÁªÑ‰ª∂
- [Component](../Component.md) - Âü∫Á°ÄÁªÑ‰ª∂Á±ª

---

**ÁâàÊú¨**: Comedot Framework v1.0  
**ÊñáÊ°£Êõ¥Êñ∞**: 2024-12-21 