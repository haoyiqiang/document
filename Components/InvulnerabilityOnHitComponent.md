# InvulnerabilityOnHitComponent API 参考

## 概述

`InvulnerabilityOnHitComponent` 在实体的 [`DamageReceivingComponent`](DamageReceivingComponent.md) 受到伤害后提供临时无敌状态。该组件适用于基于"生命值"的战斗系统，玩家可以承受有限次数的离散攻击。

**继承关系：**
`Component` → `InvulnerabilityOnHitComponent`

## 主要特性

- 🛡️ **受击无敌** - 受伤后提供临时伤害免疫
- ⏱️ **可配置时长** - 自定义无敌持续时间
- 🎬 **动画支持** - 集成AnimationPlayer进行视觉效果
- 🔄 **自动重置** - 无敌结束后自动恢复正常状态
- 🎯 **智能触发** - 仅在实际受伤时激活无敌

## 设计理念

该组件不使用 `HealthComponent` 因为：
- `HealthComponent` 可能因持续伤害源（如中毒）而失去生命值
- 这种"临时无敌"专为来自敌人的一次性伤害设计

## 导出属性

### 基础设置
```gdscript
@export var isEnabled: bool = true
```
控制组件是否启用。

### 动画设置
```gdscript
@export var animationPlayer: AnimationPlayer
```
用于播放视觉效果的动画播放器。如果为 `null`，将自动查找实体的第一个 `AnimationPlayer` 子节点。

```gdscript
@export var animationOnStart: StringName = &"invulnerabilityOnHit"
```
无敌开始时播放的动画名称。

```gdscript
@export var animationOnEnd: StringName = &"RESET"
```
无敌结束时播放的动画名称。

## 信号

### didStartInvulnerability
```gdscript
signal didStartInvulnerability
```
无敌状态开始时发出。

### didEndInvulnerability
```gdscript
signal didEndInvulnerability
```
无敌状态结束时发出。

## 只读属性

### isActive
```gdscript
var isActive: bool
```
返回当前是否处于无敌状态（基于定时器状态）。

## 子节点

### InvulnerabilityTimer
- **类型：** `Timer`
- **用途：** 控制无敌持续时间
- **配置：** 在场景中设置 `wait_time` 属性

## 主要方法

### startInvulnerability()
```gdscript
func startInvulnerability() -> void
```
开始无敌状态：
- 启动定时器
- 禁用伤害接收组件
- 重置累积分数伤害
- 应用视觉效果
- 发出信号

### endInvulnerability()
```gdscript
func endInvulnerability() -> void
```
结束无敌状态：
- 停止定时器
- 重新启用伤害接收组件
- 重置实体颜色
- 移除视觉效果
- 发出信号

## 使用示例

### 基本设置
```gdscript
# 在玩家实体场景中
extends PlayerEntity

func _ready():
    # 确保有必需的组件
    var invulnerability = $InvulnerabilityOnHitComponent
    var damageReceiving = $DamageReceivingComponent
    
    # 设置无敌时长（在定时器上设置）
    invulnerability.get_node("InvulnerabilityTimer").wait_time = 1.5
    
    # 监听无敌状态变化
    invulnerability.didStartInvulnerability.connect(_on_invulnerability_start)
    invulnerability.didEndInvulnerability.connect(_on_invulnerability_end)

func _on_invulnerability_start():
    # 播放无敌音效
    AudioManager.play_sound("invulnerable_start")
    
func _on_invulnerability_end():
    # 播放恢复音效
    AudioManager.play_sound("invulnerable_end")
```

### 视觉效果配置
```gdscript
# 在AnimationPlayer中创建"invulnerabilityOnHit"动画
# 示例：闪烁效果
func setup_invulnerability_animation():
    var animation_player = $AnimationPlayer
    var animation = Animation.new()
    animation.length = 1.5  # 与定时器时长匹配
    
    # 添加modulate轨道实现闪烁
    var track_index = animation.add_track(Animation.TYPE_VALUE)
    animation.track_set_path(track_index, ".:modulate")
    
    # 设置关键帧：透明 -> 不透明 -> 透明...
    for i in range(6):  # 闪烁3次
        var time = i * 0.25
        var alpha = 0.3 if i % 2 == 0 else 1.0
        animation.track_insert_key(track_index, time, Color(1, 1, 1, alpha))
    
    animation_player.add_animation_library("invulnerability", animation)
```

### 高级伤害系统集成
```gdscript
# 与生命值系统结合使用
extends Entity

@onready var health_component = $HealthComponent
@onready var invulnerability_component = $InvulnerabilityOnHitComponent

func _ready():
    # 监听生命值变化
    health_component.didLoseHealth.connect(_on_health_lost)
    invulnerability_component.didEndInvulnerability.connect(_on_vulnerability_restored)

func _on_health_lost(amount: int):
    # 检查是否死亡
    if health_component.currentHealth <= 0:
        handle_death()
    else:
        # 显示受伤反馈（因为无敌期间看不到伤害数字）
        show_damage_feedback(amount)

func _on_vulnerability_restored():
    # 给玩家一个视觉提示表示现在可以再次受伤
    flash_briefly(Color.WHITE)
```

### 动态无敌时长
```gdscript
# 根据游戏状态调整无敌时长
extends InvulnerabilityOnHitComponent

func adjust_invulnerability_duration(difficulty_level: int):
    var base_duration = 1.5
    var duration_modifier = {
        1: 2.0,    # 简单：更长无敌时间
        2: 1.0,    # 普通：正常时间
        3: 0.7     # 困难：更短时间
    }
    
    timer.wait_time = base_duration * duration_modifier.get(difficulty_level, 1.0)

func damageReceivingComponent_didReceiveDamage(damageComponent: DamageComponent, amount: int, attackerFactions: int):
    # 调整难度
    adjust_invulnerability_duration(GameState.difficulty_level)
    super.damageReceivingComponent_didReceiveDamage(damageComponent, amount, attackerFactions)
```

### 特殊效果系统
```gdscript
# 创建更复杂的无敌效果
extends PlayerEntity

func _ready():
    var invul = $InvulnerabilityOnHitComponent
    invul.didStartInvulnerability.connect(_create_invul_effects)
    invul.didEndInvulnerability.connect(_remove_invul_effects)

func _create_invul_effects():
    # 创建护盾粒子效果
    var shield_particles = preload("res://Effects/ShieldParticles.tscn").instantiate()
    add_child(shield_particles)
    shield_particles.emitting = true
    
    # 添加发光效果
    var glow_effect = preload("res://Effects/GlowOutline.gdshader")
    $Sprite2D.material = ShaderMaterial.new()
    $Sprite2D.material.shader = glow_effect
    
    # 创建音频循环
    $InvulnerabilitySound.play()

func _remove_invul_effects():
    # 移除所有效果
    for child in get_children():
        if child.name.begins_with("ShieldParticles"):
            child.queue_free()
    
    $Sprite2D.material = null
    $InvulnerabilitySound.stop()
```

## 技术细节

### 组件依赖
- **必需：** `DamageReceivingComponent`
- **可选：** `AnimationPlayer`（用于视觉效果）
- **推荐：** `Timer`子节点（自动包含）

### 性能考虑
- 无敌状态下完全禁用伤害接收，避免不必要的计算
- 仅在实际受伤时触发无敌，而非每次碰撞
- 自动重置累积分数伤害，避免状态不一致

### 设计模式
- **状态机模式：** 明确的无敌/易伤状态切换
- **信号驱动：** 响应式的事件处理
- **组件组合：** 与其他战斗组件无缝集成

## 注意事项

⚠️ **重要限制：**
- 无敌期间所有伤害都被忽略，包括持续伤害
- 需要确保动画时长与定时器时长匹配
- 无敌状态不会自动保存/加载

💡 **最佳实践：**
- 为不同类型的伤害源设置不同的无敌时长
- 提供清晰的视觉反馈表示无敌状态
- 考虑在无敌结束时给出提示音效

🔮 **计划改进：**
- 支持部分伤害减免而非完全免疫
- 可配置的视觉效果模板
- 与状态机系统的更好集成

## 相关组件

- [`DamageReceivingComponent`](DamageReceivingComponent.md) - 必需依赖，提供伤害接收功能
- [`HealthComponent`](HealthComponent.md) - 常用搭配，管理生命值
- [`DamageVisualComponent`](../Visual/DamageVisualComponent.md) - 视觉效果组件
- [`KnockbackOnHitComponent`](KnockbackOnHitComponent.md) - 可组合的受击效果

## 故障排除

**问题：无敌状态没有触发**
- 检查 `DamageReceivingComponent` 是否正确配置
- 确认 `isEnabled` 为 true
- 验证实际造成了伤害（amount > 0）

**问题：视觉效果不播放**
- 检查 `AnimationPlayer` 引用是否正确
- 确认动画名称拼写正确
- 验证动画是否存在于 AnimationPlayer 中

**问题：无敌时间不正确**
- 检查 Timer 子节点的 `wait_time` 设置
- 确认定时器没有被其他组件干扰 